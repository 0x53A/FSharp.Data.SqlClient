(*** hide ***)
#r @"..\..\src\SqlClient\bin\Debug\FSharp.Data.SqlClient.dll"
#r "System.Transactions"
open FSharp.Data

[<Literal>]
let connectionString = @"Data Source=.;Initial Catalog=AdventureWorks2014;Integrated Security=True"
    
(**
Transactions 
===================

<div class="well well-small" style="margin:0px 70px 0px 20px;">

This chapter assumes basic understanding of "Transactions and Concurrency" topic as applied to ADO.NET/SQL Server. 
If you need to brush up your knowledge use favorite search engine \- there is plenty information on the subject.

Following links can be useful:

 - Chapter 9 of [Microsoft SQL Server 2012 T-SQL Fundamentals](http://www.amazon.com/gp/product/0735658145). 
 - [Transactions and Concurrency in ADO.NET](https://msdn.microsoft.com/en-us/library/777e5ebh.aspx). 
 - Microsoft Virtual Academy has relevant courses
    - [Developing Microsoft SQL Server Databases. Chapter 04 - Managing Transactions.](http://www.microsoftvirtualacademy.com/training-courses/developing-microsoft-sql-server-databases) 
    - [Querying with Transact-SQL. Chapter 11 - Error Handling and Transactions.](http://www.microsoftvirtualacademy.com/training-courses/querying-with-transact-sql)

</p></div>

Explicit Transactions
-------------------------------------
Command types generated by both SqlCommandProvider and SqlProgrammabilityProvider have constructor that accepts connection instance and optionally transaction. 
This conforms familiar [ADO.NET conventions](https://msdn.microsoft.com/en-us/library/352y4sff.aspx) for commands constructors. 
*)

open System
open System.Data.SqlClient

type CurrencyCode = 
    SqlEnumProvider<"SELECT Name, CurrencyCode FROM Sales.Currency", connectionString>

type InsertCurrencyRate = SqlCommandProvider<"
        INSERT INTO Sales.CurrencyRate 
        VALUES (@currencyRateDate, @fromCurrencyCode, @toCurrencyCode, 
                @averageRate, @endOfDayRate, @modifiedDate) 
    ", connectionString>
do
    //Don't forget `use` binding to properly scope transactoin.
    //It guarantees rollback in case of unhandled exception. 

    use conn = new SqlConnection(connectionString)
    conn.Open()
    use tran = conn.BeginTransaction()
    
    //Implicit assumption that
    assert (tran.Connection = conn)
    //Supply connection and transaction 
    use cmd = new InsertCurrencyRate(conn, tran)

    let today = DateTime.Now.Date

    let recordsInserted = 
        cmd.Execute(
            currencyRateDate = today, 
            fromCurrencyCode = CurrencyCode.``US Dollar``, 
            toCurrencyCode = CurrencyCode.``United Kingdom Pound``, 
            averageRate = 0.63219M, 
            endOfDayRate = 0.63219M, 
            modifiedDate = today) 

    assert (recordsInserted = 1)

    // Invoke Commit otherwise transaction will be disposed (roll-backed) when out of scope
    tran.Commit()

(**
Note, that ``Connection`` property of transaction instance has to match connection supplied at first position. 

Typically transactions used in combination with data modification commands (INSERT, UPDATE, DELETE, MERGE) 
That said nothing stops command based on SELECT statement and/or call to a stored procedure (function) 
to join a transaction. 

*)

type AdventureWorks = SqlProgrammabilityProvider<connectionString>

do
    use conn = new SqlConnection(connectionString)
    conn.Open()
    //bump up isolation level to serializable
    use tran = conn.BeginTransaction(Data.IsolationLevel.Serializable)
    let jamesKramerId = 42

    let businessEntityID, jobTitle, hireDate = 
        //Include SELECT in transaction
        //Note that inline definition requires both design time connection string
        // and runtime connection object
        use cmd = new SqlCommandProvider<"
            SELECT 
	            BusinessEntityID
	            ,JobTitle
	            ,HireDate
            FROM 
                HumanResources.Employee 
            WHERE 
                BusinessEntityID = @id
            ", connectionString, ResultType.Tuples, SingleRow = true>(conn, tran)

        jamesKramerId |> cmd.Execute |> Option.get

    assert("Production Technician - WC60" = jobTitle)
    
    let newJobTitle = "Uber " + jobTitle

    use updatedJobTitle = new AdventureWorks.HumanResources.uspUpdateEmployeeHireInfo(conn, tran)
    let recordsAffrected = 
        updatedJobTitle.Execute(
            businessEntityID, 
            newJobTitle, 
            hireDate, 
            RateChangeDate = DateTime.Now, 
            Rate = 12M, 
            PayFrequency = 1uy, 
            CurrentFlag = true 
        )
    
    let updatedJobTitle = 
        // Static Create factory method can also be used to pass connection and/or transaction
        // It provides better intellisense. See a link below
        // https://github.com/Microsoft/visualfsharp/issues/449
        use cmd = AdventureWorks.dbo.ufnGetContactInformation.Create(conn, tran)
        //Use ExecuteSingle if you're sure it return 0 or 1 rows
        let result = cmd.ExecuteSingle(PersonID = jamesKramerId) 
        result.Value.JobTitle.Value

    assert(newJobTitle = updatedJobTitle)

    tran.Commit()

(**
Implicit a.k.a Ambient Transactions
-------------------------------------

.NET BCL class [TransactionScope](https://msdn.microsoft.com/en-us/library/system.transactions.transactionscope.aspx) is 
convenient way to deal with transactions. Basic idea is that all database connections opened within specific scope are 
enlisted in that transaction.

Example above can be re-written as following:
*)

open System.Transactions
do
    use tran = new TransactionScope()

    let jamesKramerId = 42

    let businessEntityID, jobTitle, hireDate = 
        use cmd = new SqlCommandProvider<"
            SELECT 
	            BusinessEntityID
	            ,JobTitle
	            ,HireDate
            FROM 
                HumanResources.Employee 
            WHERE 
                BusinessEntityID = @id
            ", connectionString, ResultType.Tuples, SingleRow = true>()

        jamesKramerId |> cmd.Execute |> Option.get

    assert("Production Technician - WC60" = jobTitle)
    
    let newJobTitle = "Uber " + jobTitle

    use updatedJobTitle = new AdventureWorks.HumanResources.uspUpdateEmployeeHireInfo()
    let recordsAffrected = 
        updatedJobTitle.Execute(
            businessEntityID, 
            newJobTitle, 
            hireDate, 
            RateChangeDate = DateTime.Now, 
            Rate = 12M, 
            PayFrequency = 1uy, 
            CurrentFlag = true 
        )
    
    let updatedJobTitle = 
        use cmd = new AdventureWorks.dbo.ufnGetContactInformation()
        //Use ExecuteSingle on sproc/function generated types
        //if you're sure it return 0 or 1 rows
        let result = cmd.ExecuteSingle(PersonID = jamesKramerId) 
        result.Value.JobTitle.Value

    assert(newJobTitle = updatedJobTitle)

    tran.Complete()

(**
Although very convenient `TransactoinScope` has some pitfalls and 
therefore requires good understanding of what happens behind the scene. 
Make sure you read [general usage guidelines](https://msdn.microsoft.com/en-us/library/ee818746.aspx).

There are two kind of issues you might run into when using `TransactionScope`

[Distributed Transactions](https://msdn.microsoft.com/en-us/library/ms254973.aspx)
-------------------------------------
Distributed transactions spell all kind of troubles. 
Rare necessity it should be avoided in most cases. 
Strictly speaking this problem is not specific to TransactionScope 
but automatic [Transaction Management Escalation](https://msdn.microsoft.com/en-us/library/ee818742.aspx) 
makes it's really easy to fall into the trap.

If a local transaction was accidently promoted to distributed it is software design problem. 
Have a simple check in a code right before commit to reveal the issue.: 
*)

do
    use tran = new TransactionScope()
    //your transaction logic here
    let isDistributed = Transaction.Current.TransactionInformation.DistributedIdentifier <> Guid.Empty
    if isDistributed 
    then invalidOp "Unexpected distributed transaction."
    else tran.Complete()

(**

    SqlConnection.[ConnectionString](https://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqlconnection.connectionstring.aspx) 
    has a value called [Enlist](https://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqlconnectionstringbuilder.enlist.aspx) that might be useful. 

TransactionScope + AsyncExecute 
-------------------------------------

*)